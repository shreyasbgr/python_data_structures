Instructions: 
rBST: Delete
Implement a method called delete_node to delete a node with a given value from a binary search tree (BST). The method should maintain the BST property, where the left subtree contains only nodes with values less than the parent node's value, and the right subtree contains only nodes with values greater than the parent node's value. The method should have the following signature:



def delete_node(self, value):


The method should use a private helper method called __delete_node with the following signature:



def __delete_node(self, current_node, value):


The __delete_node method should take the current node and the value to be deleted as arguments. The method should perform the following tasks:



If the current node is None, return None.

If the value is less than the current node's value, call the __delete_node method recursively on the left child of the current node.

If the value is greater than the current node's value, call the __delete_node method recursively on the right child of the current node.

If the value matches the current node's value, consider the following cases to delete the node: a. If the current node has no children, return None. b. If the current node has a right child but no left child, return the right child. c. If the current node has a left child but no right child, return the left child. d. If the current node has both left and right children, find the minimum value in the right subtree, replace the current node's value with the minimum value, and then recursively delete the minimum value node from the right subtree.

Return the current node.



The delete_node method should perform the following task:



Call the __delete_node helper method with the root and the value as arguments.

*** Solution Explanation ***
def __delete_node(self, current_node, value):
	    if current_node == None: 
		    return None
	    if value < current_node.value:
		    current_node.left = self.__delete_node(current_node.left, value)
	    elif value > current_node.value: 
		    current_node.right = self.__delete_node(current_node.right, value)
	    else:
		    if current_node.left == None and current_node.right == None:
			    return None
		    elif current_node.left == None:
			    current_node = current_node.right
		    elif current_node.right == None:
			    current_node = current_node.left
		    else:
			    sub_tree_min = self.min_value(current_node.right)
			    current_node.value = sub_tree_min
			    current_node.right = self.__delete_node(current_node.right, sub_tree_min)
	    return current_node
    
    def delete_node(self, value):
        self.__delete_node(self.root, value)




This code defines two methods for deleting a node with a given value from a binary search tree (BST): a private helper method called __delete_node and a public method called delete_node.



__delete_node method: This is a recursive method that takes two arguments - the current node and the value to be deleted. The method works as follows:

a. If the current node is None, it means the value is not found in the tree, and the method returns None.

b. If the value is less than the current node's value, the method is called recursively on the left child of the current node.

c. If the value is greater than the current node's value, the method is called recursively on the right child of the current node.

d. If the value matches the current node's value, the following cases are considered for deleting the node:

i. If the current node has no left and right children (it's a leaf node), simply remove the node by returning None.

ii. If the current node has no left child but has a right child, bypass the current node and return its right child.

iii. If the current node has no right child but has a left child, bypass the current node and return its left child.

iv. If the current node has both left and right children, find the minimum value in the right subtree (using the min_value method), replace the current node's value with the minimum value, and then recursively delete the minimum value node from the right subtree.

e. Finally, the method returns the current node after performing the necessary deletions.

delete_node method: This is the public method to delete a node with a given value from the binary search tree. It calls the __delete_node helper method with the root and the value as arguments.





Code with inline comments:



def __delete_node(self, current_node, value):
    # Return None if the current node is None
    if current_node == None:
        return None
    # Traverse the left subtree if value is smaller
    if value < current_node.value:
        current_node.left = self.__delete_node(current_node.left, value)
    # Traverse the right subtree if value is larger
    elif value > current_node.value:
        current_node.right = self.__delete_node(current_node.right, value)
    # If value is found, delete the node
    else:
        # Case 1: No children, return None to delete
        if current_node.left == None and current_node.right == None:
            return None
        # Case 2: No left child, return right child
        elif current_node.left == None:
            current_node = current_node.right
        # Case 3: No right child, return left child
        elif current_node.right == None:
            current_node = current_node.left
        # Case 4: Two children, find min in right subtree
        else:
            sub_tree_min = self.min_value(current_node.right)
            current_node.value = sub_tree_min
            current_node.right = self.__delete_node(current_node.right, sub_tree_min)
    # Return the current node after deletion
    return current_node
 
def delete_node(self, value):
    # Call the helper method to delete the node
    self.__delete_node(self.root, value)


*** OUTPUT ***
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        

class BinarySearchTree:
    def __init__(self):
        self.root = None

          
    def __r_insert(self, current_node, value):
        if current_node == None: 
            return Node(value)   
        if value < current_node.value:
            current_node.left = self.__r_insert(current_node.left, value)
        if value > current_node.value:
            current_node.right = self.__r_insert(current_node.right, value) 
        return current_node    

    def r_insert(self, value):
        if self.root == None: 
            self.root = Node(value)
        self.__r_insert(self.root, value)  


    def min_value(self, current_node):
        while (current_node.left is not None):
            current_node = current_node.left
        return current_node.value 

    ## WRITE DELETE_NODE METHODS HERE ##
    #                                  #
    #                                  #
    #                                  #
    #                                  #
    ####################################




my_tree = BinarySearchTree()
my_tree.r_insert(2)
my_tree.r_insert(1)
my_tree.r_insert(3)

"""
       2
      / \
     1   3
"""

print("root:", my_tree.root.value)
print("root.left =", my_tree.root.left.value)
print("root.right =", my_tree.root.right.value)


my_tree.delete_node(2)

"""
       3
      / \
     1   None
"""


print("\nroot:", my_tree.root.value)
print("root.left =", my_tree.root.left.value)
print("root.right =", my_tree.root.right)



"""
    EXPECTED OUTPUT:
    ----------------
	root: 2
	root.left = 1
	root.right = 3

	root: 3
	root.left = 1
	root.right = None

"""